//-----------------------------------------------------------------------------
//-- (c) Copyright 2010 Xilinx, Inc. All rights reserved.
//--
//-- This file contains confidential and proprietary information
//-- of Xilinx, Inc. and is protected under U.S. and
//-- international copyright and other intellectual property
//-- laws.
//--
//-- DISCLAIMER
//-- This disclaimer is not a license and does not grant any
//-- rights to the materials distributed herewith. Except as
//-- otherwise provided in a valid license issued to you by
//-- Xilinx, and to the maximum extent permitted by applicable
//-- law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
//-- WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
//-- AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
//-- BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
//-- INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
//-- (2) Xilinx shall not be liable (whether in contract or tort,
//-- including negligence, or under any other theory of
//-- liability) for any loss or damage of any kind or nature
//-- related to, arising under or in connection with these
//-- materials, including for any direct, or any indirect,
//-- special, incidental, or consequential loss or damage
//-- (including loss of data, profits, goodwill, or any type of
//-- loss or damage suffered as a result of any action brought
//-- by a third party) even if such damage or loss was
//-- reasonably foreseeable or Xilinx had been advised of the
//-- possibility of the same.
//--
//-- CRITICAL APPLICATIONS
//-- Xilinx products are not designed or intended to be fail-
//-- safe, or for use in any application requiring fail-safe
//-- performance, such as life-support or safety devices or
//-- systems, Class III medical devices, nuclear facilities,
//-- applications related to the deployment of airbags, or any
//-- other applications that could lead to death, personal
//-- injury, or severe property or environmental damage
//-- (individually and collectively, "Critical
//-- Applications"). Customer assumes the sole risk and
//-- liability of any use of Xilinx products in Critical
//-- Applications, subject only to applicable laws and
//-- regulations governing limitations on product liability.
//--
//-- THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
//-- PART OF THIS FILE AT ALL TIMES.
//-----------------------------------------------------------------------------
//
// AXI Slave
//
// Verilog-standard:  Verilog 2001
//--------------------------------------------------------------------------
//
// Structure:
//   axi_slave
//
//--------------------------------------------------------------------------

`timescale 1ns/1ps

module axi_slave_top_wrapper #
  (
   parameter integer C_S_AXI_ID_WIDTH             = 1,
   parameter integer C_S_AXI_ADDR_WIDTH            = 32,
   parameter integer C_S_AXI_DATA_WIDTH            = 64,
   //parameter integer C_S_AXI_AWSIZE_WIDTH          = 64,
   //parameter integer C_S_AXI_ARSIZE_WIDTH          = 8,
   parameter integer C_S_AXI_AWUSER_WIDTH          = 1,
   parameter integer C_S_AXI_ARUSER_WIDTH          = 1,
   parameter integer C_S_AXI_WUSER_WIDTH           = 1,
   parameter integer C_S_AXI_RUSER_WIDTH           = 1,
   parameter integer C_S_AXI_BUSER_WIDTH           = 1
   )
  (
    // System Signals
    input wire ACLK,
    input wire ARESETN,

    // Slave Interface Write Address Ports
    input  wire [C_S_AXI_ID_WIDTH-1:0]     S_AXI_AWID,
    input  wire [C_S_AXI_ADDR_WIDTH-1:0]   S_AXI_AWADDR,
    input  wire [8-1:0]                  S_AXI_AWLEN,
    input  wire [3-1:0]                  S_AXI_AWSIZE,
    input  wire [2-1:0]                  S_AXI_AWBURST,
    input  wire [2-1:0]                  S_AXI_AWLOCK,
    input  wire [4-1:0]                  S_AXI_AWCACHE,
    input  wire [3-1:0]                  S_AXI_AWPROT,
    input  wire [4-1:0]                  S_AXI_AWREGION,
    input  wire [4-1:0]                  S_AXI_AWQOS,
    input  wire [C_S_AXI_AWUSER_WIDTH-1:0] S_AXI_AWUSER,
    input  wire                          S_AXI_AWVALID,
    output wire                          S_AXI_AWREADY,

    // Slave Interface Write Data Ports
    input wire [C_S_AXI_ID_WIDTH-1:0]      S_AXI_WID,
    input  wire [C_S_AXI_DATA_WIDTH-1:0]   S_AXI_WDATA,
    input  wire [C_S_AXI_DATA_WIDTH/8-1:0] S_AXI_WSTRB,
    input  wire                          S_AXI_WLAST,
    input  wire [C_S_AXI_WUSER_WIDTH-1:0]  S_AXI_WUSER,
    input  wire                          S_AXI_WVALID,
    output wire                          S_AXI_WREADY,

    // Slave Interface Write Response Ports
    output wire [C_S_AXI_ID_WIDTH-1:0]    S_AXI_BID,
    output wire [2-1:0]                 S_AXI_BRESP,
    output wire [C_S_AXI_BUSER_WIDTH-1:0] S_AXI_BUSER,
    output wire                         S_AXI_BVALID,
    input  wire                         S_AXI_BREADY,

    // Slave Interface Read Address Ports
    input  wire [C_S_AXI_ID_WIDTH-1:0]     S_AXI_ARID,
    input  wire [C_S_AXI_ADDR_WIDTH-1:0]   S_AXI_ARADDR,
    input  wire [8-1:0]                  S_AXI_ARLEN,
    input  wire [3-1:0]                  S_AXI_ARSIZE,
    input  wire [2-1:0]                  S_AXI_ARBURST,
    input  wire [2-1:0]                  S_AXI_ARLOCK,
    input  wire [4-1:0]                  S_AXI_ARCACHE,
    input  wire [3-1:0]                  S_AXI_ARPROT,
    input  wire [4-1:0]                  S_AXI_ARREGION,
    input  wire [4-1:0]                  S_AXI_ARQOS,
    input  wire [C_S_AXI_ARUSER_WIDTH-1:0] S_AXI_ARUSER,
    input  wire                          S_AXI_ARVALID,
    output wire                          S_AXI_ARREADY,

    // Slave Interface Read Data Ports
    output wire [C_S_AXI_ID_WIDTH-1:0]    S_AXI_RID,
    output wire [C_S_AXI_DATA_WIDTH-1:0]  S_AXI_RDATA,
    output wire [2-1:0]                 S_AXI_RRESP,
    output wire                         S_AXI_RLAST,
    output wire [C_S_AXI_RUSER_WIDTH-1:0] S_AXI_RUSER,
    output wire                         S_AXI_RVALID,
    input  wire                         S_AXI_RREADY
  );
`include "parameters.vh"
<%- load "parameters.rb" -%>

    /*AUTOWIRE*/
    wire                    clk;
    wire                    xrst;

    wire     [LWIDTH-1:0]   fil_size;
    wire     [LWIDTH-1:0]   img_size;
    wire     [INSIZE-1:0]   input_addr;
    wire                    input_we;
    wire     [OUTSIZE-1:0]  output_addr;
    wire     [3:0]          output_re;
    wire                    req;
    wire     [LWIDTH-1:0]   total_in;
    wire     [LWIDTH-1:0]   total_out;
    wire     [WSIZE-1:0]    weight_addr;
    wire     [3:0]          weight_we;
    wire     [DWIDTH-1:0]   write_input;
    wire     [DWIDTH-1:0]   write_weight;

    wire                    ack;
    wire     [DWIDTH-1:0]   read_output;

    /*AUTOREG*/
    reg                     r_clk;
    reg                     r_xrst;

    reg      [LWIDTH-1:0]   r_fil_size;
    reg      [LWIDTH-1:0]   r_img_size;
    reg      [INSIZE-1:0]   r_input_addr;
    reg                     r_input_we;
    reg      [OUTSIZE-1:0]  r_output_addr;
    reg      [3:0]          r_output_re;
    reg                     r_req;
    reg      [LWIDTH-1:0]   r_total_in;
    reg      [LWIDTH-1:0]   r_total_out;
    reg      [WSIZE-1:0]    r_weight_addr;
    reg      [3:0]          r_weight_we;
    reg      [DWIDTH-1:0]   r_write_input;
    reg      [DWIDTH-1:0]   r_write_weight;

    reg                     r_ack;
    reg      [DWIDTH-1:0]   r_read_output;

    /* Address:
    **    0 => enable signals
    **    1 => network parameters
    **    2 ~ => normal addresses
    */
    // sm_cs: state machine current state
    assign clk                              = ACLK;
    assign xrst                             = r_xrst;
    assign output_addr                      = r_output_addr;
    assign S_AXI_RDATA[<%=$dwidth%>]        = r_ack;
    assign S_AXI_RDATA[<%=$dwidth-1%>:0]    = r_read_output;
    assign input_addr                       = r_input_addr;
    assign weight_addr                      = r_weight_addr;
    assign req                              = r_req;
    assign input_we                         = r_input_we;
    assign weight_we                        = r_weight_we;
    assign output_re                        = r_output_re;
    assign total_out                        = r_total_out;
    assign total_in                         = r_total_in;
    assign img_size                         = r_img_size;
    assign fil_size                         = r_fil_size;
    assign write_input                      = r_write_input;
    assign write_weight                     = r_write_weight;

    always @(posedge ACLK)
        if (!ARESETN)
        begin
            r_xrst              <= 0;
            r_output_addr       <= 0;
            r_ack               <= 0;
            r_read_output       <= 0;
            r_input_addr        <= 0;
            r_weight_addr       <= 0;
            r_req               <= 0;
            r_input_we          <= 0;
            r_weight_we         <= 0;
            r_output_re         <= 0;
            r_total_out         <= 0;
            r_total_in          <= 0;
            r_img_size          <= 0;
            r_fil_size          <= 0;
            r_write_input       <= 0;
            r_write_weight      <= 0;
        end
        else
        begin
            r_xrst              <= ARESETN;
            r_output_addr       <= S_AXI_ARADDR[<%=$outsize%>-1:0];
            r_ack               <= ack;
            r_read_output       <= read_output;
            case (S_AXI_AWADDR[29:28])
                2'b01:
                    r_req               <= S_AXI_WDATA[0];
                    r_input_we          <= S_AXI_WDATA[1];
                    r_weight_we         <= S_AXI_WDATA[<%=$core_log+2%>:2];
                    r_output_re         <= S_AXI_WDATA[<%=2*$core_log+2%>:<%=$core_log+3%>];
                2'b10:
                    r_fil_size          <= S_AXI_WDATA[<%=$lwidth-1%>:0]];
                    r_img_size          <= S_AXI_WDATA[<%=2*$lwidth-1%>:<%=$lwidth%>];
                    r_total_in          <= S_AXI_WDATA[<%=3*$lwidth-1%>:<%=2*$lwidth%>];
                    r_total_out         <= S_AXI_WDATA[<%=4*$lwidth-1%>:<%=3*$lwidth%>];
                default:
                    r_input_addr        <= S_AXI_AWADDR[<%=$insize%>:1];
                    r_weight_addr       <= S_AXI_AWADDR[<%=$insize+$wsize%>:<%=$insize+1%>];
                    r_write_input       <= S_AXI_WDATA[<%=$dwidth-1%>:0];
                    r_write_weight      <= S_AXI_WDATA[<%=2*$dwidth-1%>:<%=$dwidth%>];
            endcase
        end

    top top0(/*AUTOINST*/);

    // Value of S_AXI_BRESP
    localparam  RESP_OKAY   =    2'b00,
                RESP_EXOKAY =    2'b01,
                RESP_SLVERR =    2'b10,
                RESP_DECERR =    2'b11;

    // Value of S_AXI_ARBURST
    localparam  AxBURST_FIXED =    2'b00,
                AxBURST_INCR  =    2'b01,
                AxBURST_WRAP  =    2'b10;

    localparam  IDLE_WADDR =         1'b0,
                AWREADY_HOLD_OFF =    1'b1;
    reg         waddr_sm_cs;
    reg         awready;
    reg         awid;
    reg         [C_S_AXI_ADDR_WIDTH-1:0]    waddr;
    reg         [C_S_AXI_ID_WIDTH-1:0]    wid;
    reg         [2-1:0]    awburst;

    localparam  IDLE_WDATA =    1'b0,
                WREADY_ASSERT =    1'b1;
    reg         wdata_sm_cs;
    reg         wready;

    localparam  IDLE_WRES =        1'b0,
                BVALID_ASSERT =    1'b1;
    reg         wres_sm_cs;
    reg         [2-1:0]    bresp;
    reg         bvalid;

    localparam  IDLE_RADDR =        1'b0,
                ARREADY_HOLD_OFF =    1'b1;
    reg         raddr_sm_cs;
    reg         arready;
    reg         [C_S_AXI_ID_WIDTH-1:0]    arid;
    reg         [C_S_AXI_ADDR_WIDTH-1:0]    raddr;

    localparam  IDLE_RDATA =    1'b0,
                RVALID_ASSERT =    1'b1;
    reg         rdata_sm_cs;
    reg         rvalid;
    reg         [C_S_AXI_ID_WIDTH-1:0]    rid;
    reg         [1:0]    rresp;
    reg         [8:0]    rdata_count;

    localparam  IDLE_RLAST =     1'b0,
                RLAST_ASSERT =    1'b1;
    reg         rlast_sm_cs;
    reg         rlast;

    // Write Transaction
    assign S_AXI_BUSER = 1'd0;

    // waddr State Machine
    // awready is normally 1. if S_AXI_AWVALID is 1 then awready is 0.
    always @(posedge ACLK)
        if (!ARESETN)
        begin
            waddr_sm_cs <= IDLE_WADDR;
            awready     <= 1'b1;
            awid        <= {C_S_AXI_ID_WIDTH{1'b0}};
            awburst     <= 2'd0;
        end
        else
            case (waddr_sm_cs)
                /*
                    when WADDR is idle, down awready.
                    if bvalid is up, awready comes back.
                        => what's bvalid ?

                    solutions goes like:
                        => bvalid indicates Write response valid.
                           This signal indicates that a valid write response is available:
                            1 = write response available
                            0 = write response not available.
                            (cf. http://mazsola.iit.uni-miskolc.hu/~drdani/docs_arm/AMBAaxi.pdf)
                        => AWVALID typically asserts for a clock. so AWREADY deasserts when trans end.
                */
                IDLE_WADDR:
                    if (S_AXI_AWVALID)
                    begin
                        waddr_sm_cs <= AWREADY_HOLD_OFF;
                        awready     <= 1'b0;
                        awid        <= S_AXI_AWID;
                        awburst     <= S_AXI_AWBURST;
                    end
                AWREADY_HOLD_OFF: // when writing data
                    if (bvalid)
                    begin
                        waddr_sm_cs <= IDLE_WADDR;
                        awready     <= 1'b1;
                    end
            endcase

    assign S_AXI_AWREADY = awready;

    // waddr
    always @(posedge ACLK)
        if (!ARESETN)
            waddr <= {C_S_AXI_ADDR_WIDTH{1'b0}};
        else
            if (waddr_sm_cs == IDLE_WADDR & S_AXI_AWVALID)
                waddr <= S_AXI_AWADDR;
            else if (wready & S_AXI_WVALID)
                waddr <= waddr + C_S_AXI_DATA_WIDTH/8;

    // wdata State Machine
    always @(posedge ACLK)
        if (!ARESETN)
        begin
            wdata_sm_cs <= IDLE_WDATA;
            wready      <= 1'b0;
        end
        else
            case (wdata_sm_cs)
                IDLE_WDATA :
                    if (waddr_sm_cs == IDLE_WADDR && S_AXI_AWVALID)
                    begin // Write transaction start
                        wdata_sm_cs <= WREADY_ASSERT;
                        wready <= 1'b1;
                    end
                WREADY_ASSERT :
                    if (S_AXI_WLAST & S_AXI_WVALID)
                    begin    // Write transaction end
                        wdata_sm_cs <= IDLE_WDATA;
                        wready <= 1'b0;
                    end
            endcase

    assign S_AXI_WREADY = wready;

    assign S_AXI_BID = awid;
    // Write Response State Machine
    always @(posedge ACLK)
        if (!ARESETN)
        begin
            wres_sm_cs <= IDLE_WRES;
            bvalid     <= 1'b0;
        end
        else
            case (wres_sm_cs)
                /*
                    bvalid stands for valid state of bus
                */
                IDLE_WRES :
                    if (wdata_sm_cs == WREADY_ASSERT & S_AXI_WLAST & S_AXI_WVALID)
                    begin    // Write transaction end
                        wres_sm_cs <= BVALID_ASSERT;
                        bvalid     <= 1'b1;
                    end
                BVALID_ASSERT :
                    if (S_AXI_BREADY)
                    begin
                        wres_sm_cs <= IDLE_WRES;
                        bvalid     <= 1'b0;
                    end
            endcase

    assign S_AXI_BVALID = bvalid;

    // bresp
    // if S_AXI_AWBURST is INCR then return OKAY else return SLVERR
    always @(posedge ACLK)
        if (!ARESETN)
            bresp <= 2'b0;
        else
            if (waddr_sm_cs == AWREADY_HOLD_OFF)
                if (awburst == AxBURST_INCR) // The burst type is Addres Increment Type
                    bresp <= RESP_OKAY; // The Write Transaction is success
                else
                    bresp <= RESP_SLVERR; // Error

    assign S_AXI_BRESP = bresp;

    // Read Transaction
    assign S_AXI_RUSER = 0;

    // raddr State Machine
    // arready is normally 1. if S_AXI_ARVALID is 1 then arready is 0.
    always @(posedge ACLK)
        if (!ARESETN)
        begin
            raddr_sm_cs <= IDLE_RADDR;
            arready     <= 1'b1;
            arid        <= {C_S_AXI_ID_WIDTH{1'b0}};
        end
        else
            case (raddr_sm_cs)
                IDLE_RADDR :
                    if (S_AXI_ARVALID)
                    begin
                        raddr_sm_cs <= ARREADY_HOLD_OFF;
                        arready     <= 1'b0;
                        arid        <= S_AXI_ARID;
                    end
                ARREADY_HOLD_OFF :
                    if (rvalid & S_AXI_RREADY & S_AXI_RLAST)
                    begin // Read Transaction End
                        raddr_sm_cs <= IDLE_RADDR;
                        arready     <= 1'b1;
                    end
            endcase

    assign S_AXI_ARREADY = arready;

    // raddr
    always @(posedge ACLK)
        if (!ARESETN)
            raddr <= {C_S_AXI_ADDR_WIDTH{1'b0}};
        else
            if (raddr_sm_cs == IDLE_RADDR & S_AXI_ARVALID)
                raddr <= S_AXI_ARADDR;
            else if (rvalid & S_AXI_RREADY)
                raddr <= raddr + C_S_AXI_ADDR_WIDTH/8;

    // rdata State Machine
    always @(posedge ACLK)
        if (!ARESETN)
        begin
            rdata_sm_cs <= IDLE_RDATA;
            rvalid      <= 1'b0;
            rid         <= {C_S_AXI_ID_WIDTH{1'b0}};
        end
        else
            case (rdata_sm_cs)
                IDLE_RDATA :
                    if (raddr_sm_cs == IDLE_RADDR & S_AXI_ARVALID)
                    begin
                        rdata_sm_cs <= RVALID_ASSERT;
                        rvalid      <= 1'b1;
                    end
                RVALID_ASSERT :
                    if (rlast & S_AXI_RREADY)
                    begin
                        rdata_sm_cs <= IDLE_RDATA;
                        rvalid      <= 1'b0;
                    end
            endcase

    assign S_AXI_RVALID = rvalid;
    assign S_AXI_RID = arid;

    //     assign S_AXI_RRESP = RESP_OKAY;
    always @(posedge ACLK)
        if (!ARESETN)
            rresp <= RESP_OKAY;
        else if (rdata_sm_cs == RVALID_ASSERT && rid != arid)
            rresp <= RESP_SLVERR;

    assign S_AXI_RRESP = rresp;

    // rdata_count
    // data amount to be transferred
    // indicates the burst length
    always @(posedge ACLK)
        if (!ARESETN)
            rdata_count <= 9'd0;
        else
            if (raddr_sm_cs == IDLE_RADDR & S_AXI_ARVALID)
                rdata_count <= {1'b0, S_AXI_ARLEN} + 9'd1;
            else if (rvalid & S_AXI_RREADY)
                rdata_count <= rdata_count - 9'd1;

    // rlast
    always @(posedge ACLK)
        if (!ARESETN)
        begin
            rlast_sm_cs <= IDLE_RLAST;
            rlast       <= 1'b0;
        end
        else
            case (rlast_sm_cs)
                IDLE_RLAST :
                    // rdata_count is 9'd2 and when transaction is issued
                    if (rdata_count == 9'd2 && (rvalid & S_AXI_RREADY))
                    begin
                        rlast_sm_cs <= RLAST_ASSERT;
                        rlast       <= 1'b1;
                    end else if (raddr_sm_cs==IDLE_RADDR && S_AXI_ARVALID==1'b1 && S_AXI_ARLEN==8'd0)
                    begin
                    // 転送数が1の時はデータ転送の最初からrlast を1にする
                        rlast_sm_cs <= RLAST_ASSERT;
                        rlast       <= 1'b1;
                    end
                RLAST_ASSERT :
                    if (rvalid & S_AXI_RREADY)
                    begin
                        rlast_sm_cs <= IDLE_RLAST;
                        rlast       <= 1'b0;
                    end
            endcase

    assign S_AXI_RLAST = rlast;

endmodule
